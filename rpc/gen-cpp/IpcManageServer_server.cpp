// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.


#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include <iostream>
#include <stdexcept>
#include <sstream>

#include "IpcManageServer.h"

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::ipcms;
//using namespace  shared;

class IpcManageServerHandler : virtual public IpcManageServerIf {
 public:
  IpcManageServerHandler() {
    // Your initialization goes here
  }

  void UserLogin( ::ipcms::UserLoginReturnStruct& _return, const std::string& userName) {
    // Your implementation goes here
    printf("UserLogin\n");
	_return.SessionID = "11";
	_return.UserID = "22";
  }

  void GetResInfoList(std::vector< ::ipcms::ResourceInfoReturnStruct> & _return, const  ::ipcms::UserVerificationDataPacket& userVerify, const int32_t resType) {
    // Your implementation goes here
    printf("GetResInfoList\n");
  }

  int8_t PlayVideo(const  ::ipcms::UserVerificationDataPacket& userVerify, const  ::ipcms::PlayVideoDataPacket& playVideo) {
    // Your implementation goes here
    printf("PlayVideo\n");
	return 0;
  }

  void ApplyPTZControl( ::ipcms::ApplyPTZControlReturnStruct& _return, const  ::ipcms::UserVerificationDataPacket& userVerify, const  ::ipcms::ApplyPTZControlDataPacket& applyPtz) {
    // Your implementation goes here
    printf("ApplyPTZControl\n");
  }

  bool UserLogout(const  ::ipcms::UserVerificationDataPacket& userVerify) {
    // Your implementation goes here
    printf("UserLogout\n");
	return true;
  }

};

int main(int argc, char **argv) {
	
	boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	boost::shared_ptr<IpcManageServerHandler> handler(new IpcManageServerHandler());
	boost::shared_ptr<TProcessor> processor(new IpcManageServerProcessor(handler));
	boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(9090));
	boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());

	/*const int workCount = 4;

	boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workCount);
	boost::shared_ptr<PosixThreadFactory> threadFactory = boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();*/

	/*TThreadPoolServer server(processor,
		serverTransport,
		transportFactory,
		protocolFactory,
		threadManager);*/
	TThreadedServer server(processor,
		serverTransport,
		transportFactory,
		protocolFactory);

	cout << "Starting the server...." << endl;
	server.serve();

	cout << "Done.. " <<endl;



	/*int port = 9090;
	shared_ptr<IpcManageServerHandler> handler(new IpcManageServerHandler());
	shared_ptr<TProcessor> processor(new IpcManageServerProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();*/


  return 0;
}

